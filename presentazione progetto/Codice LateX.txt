\documentclass[12pt, a4paper]{report}

% --- PACCHETTI FONDAMENTALI ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\usepackage{graphicx}       % Per le immagini (UML)
\usepackage{geometry}       % Per i margini
\usepackage{hyperref}       % Per l'indice cliccabile
\usepackage{listings}       % Per il codice C++
\usepackage{xcolor}         % Per i colori del codice
\usepackage{float}          % Per posizionare le immagini esattamente dove vuoi

% --- CONFIGURAZIONE MARGINI ---
\geometry{
    a4paper,
    top=2.5cm,
    bottom=2.5cm,
    left=3cm,
    right=3cm
}

% --- CONFIGURAZIONE CODICE C++ ---
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    language=C++
}
\lstset{style=mystyle}

% --- INFORMAZIONI DOCUMENTO ---
\newcommand{\titoloProgetto}{Gestione Preventivi EdilColor - Stima costi tinteggiatura, decorativi e cartongesso}
\newcommand{\nomeGruppo}{Gruppo EdilColor Team}
\newcommand{\versioneDoc}{1.0}
\newcommand{\dataDoc}{\today}

\begin{document}

% ------------------------------------------------------------------
% 1. FRONTESPIZIO (Titolo, Gruppo, Data, Componenti)
% ------------------------------------------------------------------
\begin{titlepage}
    \centering
    \vspace*{1cm}

    \Huge
    \textbf{\titoloProgetto}

    \vspace{0.5cm}
    \LARGE
    \nomeGruppo

    \vspace{1.5cm}

    \textbf{Documentazione di Progetto}

    \vspace{0.5cm}
    \large
    Versione \versioneDoc

    \vfill

    \textbf{Componenti del Gruppo:}
    \begin{itemize}
        \centering
        \item Nicola Avellino (243294)
        \item Riccardo Gonzato (246476)
    \end{itemize}

    \vfill

    \large
    \dataDoc

\end{titlepage}

% ------------------------------------------------------------------
% 4. INDICE
% ------------------------------------------------------------------
\tableofcontents
\newpage

% ------------------------------------------------------------------
% ------------------------------------------------------------------
% 5. DESCRIZIONE DEL PROGETTO
% ------------------------------------------------------------------
\chapter{Descrizione del Progetto}

L'applicativo realizzato nasce per rispondere a una specifica esigenza operativa nel rapporto tra \textbf{committente} (cliente) e \textbf{professionista} (impresa).

Spesso, infatti, il cliente necessita unicamente di un ordine di grandezza immediato dei costi per valutare la fattibilità di un lavoro, mentre il professionista si trova a investire tempo prezioso in sopralluoghi e calcoli analitici anche per richieste che, frequentemente, non si traducono in commesse reali.

Il software risolve questa inefficienza strutturale offrendo un vantaggio reciproco immediato:

\begin{itemize}
    \item \textbf{Per il Cliente:} Fornisce istantaneamente un'idea verosimile di spesa (\textit{"stima preliminare"}), senza attese e senza l'impegno psicologico di richiedere un preventivo formale.

    \item \textbf{Per il Professionista:} Funge da \textit{filtro preliminare}, automatizzando la fase di primo contatto. Questo permette all'impresa di dedicare le risorse umane e il tempo tecnico esclusivamente alle fasi esecutive o alle trattative già confermate.
\end{itemize}

\section{Obiettivi del Progetto}
Oltre alla risoluzione della problematica operativa, il progetto si pone precisi obiettivi tecnici e funzionali:

\begin{enumerate}
    \item \textbf{Rapidità di Utilizzo:} Minimizzare il numero di input richiesti all'utente (mq,grado difficoltà e tipologia), delegando al sistema la complessità del calcolo dei materiali e della manodopera.

    \item \textbf{Coerenza dei Prezzi:} Standardizzare le quotazioni applicando listini predefiniti e coefficienti di difficoltà (es. \textit{locale abitato} vs \textit{nuovo}) in modo automatico, eliminando la soggettività e l'errore umano tipico delle stime "a braccio".

    \item \textbf{Architettura Estendibile (OOD):} Realizzare un sistema software basato su una solida progettazione a oggetti. L'uso di \textit{Design Pattern} (come Builder e Strategy) garantisce che l'aggiunta futura di nuove categorie di lavori (es. pavimentazioni) non richieda la riscrittura del codice esistente, ma solo l'estensione delle classi base.
\end{enumerate}

% ------------------------------------------------------------------
% 6. REQUISITI
% ------------------------------------------------------------------
\chapter{Requisiti del Sistema}
In questo capitolo vengono dettagliati i requisiti funzionali (RF) e non funzionali (RNF) che hanno guidato lo sviluppo dell'applicazione.

\section{Requisiti Funzionali}
I requisiti funzionali descrivono i comportamenti specifici e le funzioni che il sistema mette a disposizione dell'utente.

\begin{itemize}
    \item \textbf{RF1 - Gestione del Contesto Operativo (Difficoltà):}
    Il sistema deve permettere all'utente di definire lo stato dell'immobile (es. \textit{Nuovo, Abitato, Disabitato}). Sulla base di questa scelta, l'applicazione deve applicare automaticamente dei \textbf{coefficienti correttivi} al listino base per adeguare il prezzo alla complessità logistica.

    \item \textbf{RF2 - Gestione Listini Centralizzata:}
    Il sistema utilizza un catalogo dei cicli (interno/esterno/cartongesso) per presentare le lavorazioni disponibili e un listino prezzi per gestire coefficienti di difficoltà e prezzi al mq delle lavorazioni. I coefficienti correttivi vengono applicati automaticamente in base allo stato dell'immobile.

    \item \textbf{RF3 - Creazione e Composizione Preventivi:}
    L'utente deve poter creare un nuovo preventivo (associato a un ID univoco e a un cliente) e popolarlo aggiungendo diverse tipologie di voci di costo. Il sistema deve supportare l'inserimento di:
    \begin{itemize}
        \item \textit{Voci Semplici:} (es. Tinteggiature) che richiedono solo la superficie.
        \item \textit{Voci Complesse:} (es. Cartongesso) create tramite Builder in ottica estendibile; nella versione attuale la configurazione è semplificata.
    \end{itemize}

    \item \textbf{RF4 - Calcolo Automatico dei Totali:}
    Il sistema calcola il costo di ogni voce (mq $\times$ prezzo unitario $\times$ coefficiente) tramite il metodo \texttt{subtotale()} delle singole lavorazioni. Il totale complessivo viene calcolato quando richiesto (riepilogo e/o salvataggio) iterando polimorficamente sulle voci del preventivo.

    \item \textbf{RF5 - Persistenza e Esportazione Dati:}
    Il preventivo viene esportato su file in formato TXT e CSV tramite funzioni dedicate del modulo di salvataggio.
    Il salvataggio dei due formati viene eseguito in \textbf{concorrenza} (due task paralleli) con sincronizzazione dell'output su console.
    Nel CSV è presente un'intestazione e una riga per ogni voce; seguono righe di riepilogo (imponibile, IVA, totale).

    \item \textbf{RF6 - Interfaccia Utente (CLI):}
    L'interazione deve avvenire tramite interfaccia a riga di comando (Console), guidando l'utente attraverso menu numerici sequenziali per minimizzare gli errori di input.
\end{itemize}

\section{Requisiti Non Funzionali}
I requisiti non funzionali definiscono gli attributi di qualità del sistema e i vincoli progettuali.

\begin{itemize}
    \item \textbf{RNF1 - Architettura Object-Oriented (OOD):}
    Il sistema deve essere progettato seguendo rigorosamente il paradigma a oggetti. Deve utilizzare il \textbf{Polimorfismo} per trattare in modo uniforme lavorazioni diverse (tramite classe astratta \texttt{VoceCosto}) e garantire l'incapsulamento dei dati.

    \item \textbf{RNF2 - Estendibilità (Open/Closed Principle):}
    L'architettura deve permettere l'aggiunta di nuove categorie di lavorazioni (es. Pavimentazioni) o nuove regole di calcolo senza dover modificare la logica del gestore dei preventivi, ma estendendo le classi esistenti.

    \item \textbf{RNF3 - Integrità dei Dati:}
    L'uso di puntatori intelligenti (\texttt{std::unique\_ptr}, \texttt{std::shared\_ptr}) è richiesto per garantire una corretta gestione della memoria (RAII), prevenendo memory leak durante la creazione e distruzione dei preventivi.

    \item \textbf{RNF4 - Performance:}
    Il calcolo del preventivo deve essere istantaneo al momento dell'inserimento dei dati, senza latenze percepibili dall'utente, se non quelle inserite volutamente per scopo didattico.

    \item \textbf{RNF5 - Affidabilità e Concorrenza Controllata:}
    Le operazioni di I/O (salvataggio TXT/CSV) sono eseguite in modo concorrente tramite \texttt{std::thread}, con uso di \texttt{std::mutex} e \texttt{std::atomic} per evitare race condition.
    Gli errori di configurazione (es. chiavi mancanti nel listino) e di I/O (file non apribili) vengono gestiti tramite \textbf{eccezioni}.
\end{itemize}

% ------------------------------------------------------------------
% 7. ATTIVITÀ SVOLTE
% ------------------------------------------------------------------
\chapter{Attività Svolte}
Lo sviluppo del progetto si è articolato in cinque fasi principali:

\begin{enumerate}
    \item \textbf{Analisi del Dominio e dei Requisiti}
    \begin{itemize}
        \item Studio delle dinamiche reali di preventivazione edile per individuare le entità fondamentali (Cliente, Preventivo, Voce di Costo, Listino).
        \item Identificazione delle variabili critiche per il calcolo dei prezzi (superfici, coefficienti di difficoltà ambientale).
        \item Formalizzazione dei requisiti funzionali (es. necessità di salvare su file) e non funzionali (es. estendibilità del codice).
    \end{itemize}

    \item \textbf{Progettazione Architetturale (OOD)}
    \begin{itemize}
        \item Definizione della gerarchia delle classi tramite diagrammi UML.
        \item Scelta delle strutture dati più idonee: utilizzo di \texttt{std::vector} per la gestione dinamica delle voci e \texttt{std::map} per l'accesso rapido ai listini prezzi.
        \item Progettazione della gestione della memoria: decisione di utilizzare \textbf{Smart Pointers} (\texttt{std::unique\_ptr}) per garantire la proprietà esclusiva delle voci all'interno del preventivo e prevenire memory leak.
    \end{itemize}

    \item \textbf{Sviluppo delle Classi Core}
    \begin{itemize}
        \item Implementazione della classe astratta \texttt{VoceCosto} per definire l'interfaccia comune (metodo \texttt{subtotale()} virtuale puro).
        \item Implementazione della classe container \texttt{Preventivo}, capace di gestire polimorficamente collezioni eterogenee di lavori.
        \item Creazione del modulo \texttt{ListinoPrezzi} per centralizzare la gestione delle tariffe e dei coefficienti di maggiorazione.
    \end{itemize}

    \item \textbf{Implementazione dei Design Pattern}
    \begin{itemize}
        \item \textbf{Pattern Builder (Predisposizione Architetturale):} Adozione di \texttt{VoceCartongessoBuilder} per la creazione della classe \texttt{VoceCartongesso}. Sebbene nell'attuale versione del software la voce non presenti una struttura interna complessa, il Builder è stato implementato in ottica di \textbf{estendibilità futura}. L'obiettivo è predisporre il sistema ad accogliere configurazioni articolate (es. aggiunta di lastre ignifughe, isolanti acustici o orditure doppie) senza dover ristrutturare l'intero codice.
        \item \textbf{Pattern Strategy:} Implementazione delle classi \texttt{RegolaCosto} per disaccoppiare l'algoritmo di creazione e calcolo dal client, permettendo di selezionare la strategia corretta a runtime in base alla scelta dell'utente.
    \end{itemize}

    \item \textbf{Testing, Debugging e Refactoring}
    \begin{itemize}
        \item Verifica del corretto funzionamento tramite casi d'uso reali (es. creazione di preventivi misti Cartongesso/Tinteggiatura).
        \item Debugging della gestione dell'input utente (classe \texttt{GestioneInputUI}) per evitare crash su inserimenti non validi.
        \item Test di persistenza: verifica della correttezza dei file CSV generati e della loro leggibilità.
    \end{itemize}
    
    \item \textbf{Integrazione funzionalità di C++ moderno (C++11)}
    \begin{itemize}
    \item Implementazione di \textbf{Copy/Move semantics} e overload di operatori (es. \texttt{operator=} e \texttt{operator+=}) per la classe \texttt{Preventivo}.
    \item Uso di \textbf{STL algorithms} (\texttt{std::accumulate}, \texttt{std::sort}) e \textbf{lambda} per calcoli e ordinamenti.
    \item Introduzione di una funzione \textbf{template} di aggregazione per calcoli riutilizzabili.
    \item Salvataggio concorrente con \texttt{std::thread}, sincronizzazione con \texttt{mutex} e stato con \texttt{atomic}.
    \end{itemize}
    
\end{enumerate}
% ------------------------------------------------------------------
% 8. ATTIVITÀ DI IMPLEMENTAZIONE
% ------------------------------------------------------------------
\chapter{Attività di Implementazione}

In questo capitolo viene descritta l'architettura tecnica della soluzione, dettagliando le scelte di Object-Oriented Design (OOD), la mappatura tra casi d'uso e oggetti software, e le modalità di persistenza dei dati.

% ------------------------------------------------------------------
% 8a. OOD
% ------------------------------------------------------------------
\section{Object-Oriented Design (OOD)}
L'architettura del software si basa su una rigorosa applicazione dei principi della programmazione a oggetti, sfruttando polimorfismo, incapsulamento e smart pointers per la gestione delle risorse.

Di seguito vengono descritte le classi principali, le loro responsabilità e le relazioni cardinali.

\subsection{Descrizione delle Classi e delle Relazioni}

\begin{description}
    \item[Preventivo] \hfill \\
    È la classe "Container" principale del sistema. Rappresenta l'entità logica del preventivo associato a un cliente.
    \begin{itemize}
        \item \textbf{Proprietà:}
            \begin{itemize}
                \item \texttt{id\_ (string)}: Identificativo univoco del preventivo.
                \item \texttt{cliente\_ (string)}: Nome del committente.
                \item \texttt{grado\_ (GradoDifficolta)}: Enum che definisce lo stato dell'immobile (es. \textit{Abitato}), influenzando i costi.
                \item \texttt{voci\_ (vector<unique\_ptr<VoceCosto>>)}: Collezione polimorfica delle lavorazioni.
               \item \texttt{voci\_ (vector<unique\_ptr<VoceCosto>>)}: Collezione polimorfica delle lavorazioni.
               \item \texttt{chiaviVoci\_ (set<string>)}: Set di chiavi logiche (\textit{tipo|nome}) usato come guardia per evitare duplicati; se una lavorazione è già presente, si uniscono le quantità.
\end{itemize}
        \item \textbf{Metodi Principali:}
            \begin{itemize}
                \item \texttt{aggiungiVoce(unique\_ptr<VoceCosto>)}: Inserisce una nuova lavorazione trasferendo la proprietà del puntatore (move semantics).
                \item \texttt{totale()}: Itera sul vettore \texttt{voci\_} invocando polimorficamente \texttt{subtotale()}.
                \item \texttt{riepilogo()}: Genera una stringa formattata  con il dettaglio di tutte le voci.
                \item \texttt{aggiungiVoce(unique\_ptr<VoceCosto>)}: Inserisce una nuova lavorazione (move). Se esiste già (stesso tipo+nome) unisce le quantità invece di creare un duplicato.
            \end{itemize}
        \item \textbf{Relazioni:}
            \begin{itemize}
                \item \textbf{Composizione (1 a 0..*):} \texttt{Preventivo} possiede esclusivamente le istanze di \texttt{VoceCosto} tramite \texttt{std::unique\_ptr}. La distruzione del preventivo comporta la distruzione delle voci.
            \end{itemize}
    \end{itemize}

    \item[VoceCosto (Classe Astratta)] \hfill \\
    Classe base che definisce l'interfaccia comune per qualsiasi tipo di lavorazione.
    \begin{itemize}
        \item \textbf{Proprietà (Protected):} \texttt{nome\_}, \texttt{unitaMisura\_}, \texttt{quantita\_}, \texttt{prezzoUnitario\_}, \texttt{coefficiente\_}.
        \item \textbf{Metodi:}
            \begin{itemize}
                \item \texttt{tipoVoce() (virtual pure)}: etichetta logica della voce (stampe/CSV).
                \item \texttt{subtotale() (virtual pure)}: Metodo astratto che deve essere implementato dalle sottoclassi per calcolare il costo specifico.
                \item \texttt{clone()}: Implementa il pattern Prototype per la duplicazione profonda degli oggetti.
            \end{itemize}
        \item \textbf{Relazioni:}
            \begin{itemize}
                \item \textbf{Generalizzazione:} Padre di \texttt{VoceTinteggiatura} e \texttt{VoceCartongesso}.
            \end{itemize}
    \end{itemize}

    \item[VoceTinteggiatura e VoceCartongesso] \hfill \\
    Classi concrete che implementano la logica specifica di calcolo.
    \begin{itemize}
        \item \textbf{Costruttore:} Riceve un riferimento a \texttt{ListinoPrezzi} per cercare il prezzo base in funzione del nome del ciclo selezionato e applica il coefficiente di difficoltà.
        \item \textbf{Relazioni:}
            \begin{itemize}
                \item \textbf{Dipendenza:} Usano \texttt{ListinoPrezzi} e \texttt{GradoDifficolta} in fase di costruzione.
            \end{itemize}
    \end{itemize}

    \item[VoceCartongessoBuilder] \hfill \\
    Implementazione del \textbf{Pattern Builder} per la creazione controllata di voci complesse.
    \begin{itemize}
        \item \textbf{Proprietà:} Mantiene temporaneamente i parametri (\texttt{mq\_}, \texttt{listino\_}, ecc.) necessari alla costruzione.
        \item \textbf{Metodi:} \texttt{setNomeCiclo()}, \texttt{setMq()}, \texttt{setListino()}, \texttt{setGrado()}, \texttt{build()}.
        \item \textbf{Relazioni:}
            \begin{itemize}
                \item \textbf{Associazione:} Mantiene uno \texttt{shared\_ptr} al \texttt{ListinoPrezzi}.
                \item \textbf{Creazione:} Istanzia oggetti \texttt{VoceCartongesso}.
            \end{itemize}
    \end{itemize}
\item[CatalogoCicli] \hfill \\
Modulo di dominio che rappresenta un \textbf{catalogo statico} delle lavorazioni disponibili.
Contiene metadati (nome ciclo, prezzo base €/mq, categoria e sottocategoria) e funzioni di accesso controllato.
\begin{itemize}
    \item \textbf{Entità principali:} \texttt{CicloInfo} (\texttt{nome}, \texttt{prezzoMq}, \texttt{CategoriaLavoro},\\
    \texttt{SottoCategoriaLavoro}).
    \item \textbf{Funzioni:} \texttt{getNumeroCicli()}, \texttt{getCiclo(index)}.
    \item \textbf{Helper per UI:} \texttt{getNomeCicloDaIndice()}, \texttt{isCartongessoIndex()}.
    \item \textbf{Relazioni:}
    \begin{itemize}
        \item \textbf{Dipendenza:} usato da \texttt{GestioneInputUI} per mostrare i menu e da \texttt{ListinoDefault} per caricare i prezzi.
    \end{itemize}
\end{itemize}

\item[ListinoDefault] \hfill \\
Modulo di inizializzazione che carica nel \texttt{ListinoPrezzi} i \textbf{prezzi base} e i \textbf{coefficienti standard}.
\begin{itemize}
    \item \textbf{Funzione:} \texttt{caricaListinoDefault(ListinoPrezzi\&)}.
    \item \textbf{Comportamento:} importa i prezzi €/mq da \texttt{CatalogoCicli} e imposta i coefficienti per \texttt{GradoDifficolta}.
    \item \textbf{Relazioni:}
    \begin{itemize}
        \item \textbf{Dipendenza:} usa \texttt{CatalogoCicli} e configura \texttt{ListinoPrezzi} all'avvio.
    \end{itemize}
\end{itemize}

\item[GestioneInputUI] \hfill \\
Strato di interfaccia testuale (CLI) responsabile dei menu e della \textbf{validazione input}.
\begin{itemize}
    \item \textbf{Nota progettuale:} classe \textbf{stateless} (metodi statici).
    \item \textbf{Metodi:} \texttt{chiediGradoDifficolta()}, \texttt{chiediCategoriaLavoro()},\\ \texttt{chiediSottoCategoriaLavoro()}, \texttt{menuCicliPerCategoria()}.
    \item \textbf{Relazioni:}
    \begin{itemize}
        \item \textbf{Dipendenza:} utilizza \texttt{CatalogoCicli} (categorie/sottocategorie e lista cicli).
    \end{itemize}
\end{itemize}

\item[Utils] \hfill \\
Modulo di funzioni di supporto per ridurre duplicazione nel codice e rendere robusta la gestione input.
\begin{itemize}
    \item \textbf{Input robusto:} lettura tramite \texttt{getline} e parsing (\texttt{leggiIntero()}, \texttt{leggiDouble()}).
    \item \textbf{Validazione:} \texttt{nomeClienteValido()}, \texttt{chiediConferma()}.
    \item \textbf{Utility:} \texttt{trim()}.
    \item \textbf{Thread-safety:} \texttt{getLocalTimeSafe()} per ottenere la data locale evitando data race su \texttt{std::localtime}.
\end{itemize}

\item[IdPreventivoGenerator] \hfill \\
Modulo che genera l'identificativo univoco del preventivo in formato \texttt{PYYYYMMDD-XXX}.
\begin{itemize}
    \item \textbf{Funzione:} \texttt{generaIdPreventivo()}.
    \item \textbf{Dettagli:} usa un contatore progressivo (\texttt{std::atomic<int>}) e la data ottenuta tramite \texttt{Utils::getLocalTimeSafe()}.
\end{itemize}

\item[SalvataggioPreventivo] \hfill \\
Modulo di persistenza responsabile dell'esportazione del preventivo su file.
\begin{itemize}
    \item \textbf{Funzioni:} \texttt{salvaPreventivoSuTxt()}, \texttt{salvaPreventivoSuCsv()}.
    \item \textbf{Salvataggio concorrente:} \texttt{salvaPreventivoConcorrente()} avvia due thread (TXT e CSV) e sincronizza output su console (\texttt{std::mutex}); lo stato di completamento usa variabili atomiche.
    \item \textbf{Relazioni:}
    \begin{itemize}
        \item \textbf{Dipendenza:} legge i dati dal \texttt{Preventivo} tramite getter e iterazione sulle \texttt{VoceCosto}.
    \end{itemize}
\end{itemize}

    \item[CalcolatorePreventivo] \hfill \\
    Classe che orchestra la creazione delle voci utilizzando il \textbf{Pattern Strategy}.
    \begin{itemize}
        \item \textbf{Proprietà:} \texttt{regola\_ (const RegolaCosto*)}: Puntatore alla strategia di creazione corrente.
        \item \textbf{Metodi:}
            \begin{itemize}
                \item \texttt{setRegola()}: Cambia dinamicamente la strategia (es. da Tinteggiatura a Cartongesso).
                \item \texttt{aggiungiLavoro()}: Delega alla regola corrente la creazione della voce e la aggiunge al preventivo.
            \end{itemize}
        \item \textbf{Relazioni:}
            \begin{itemize}
                \item \textbf{Aggregazione (0..1):} Riferisce a una \texttt{RegolaCosto} senza possederla.
            \end{itemize}
    \end{itemize}

    \item[ListinoPrezzi] \hfill \\
    Database in-memory dei costi e dei coefficienti.
    \begin{itemize}
        \item \textbf{Struttura Dati:} Utilizza \texttt{std::map<string, double>} per associare i nomi dei cicli ai prezzi e \texttt{std::map<GradoDifficolta, double>} per i coefficienti.
    \end{itemize}
\end{description}

% ------------------------------------------------------------------
% 8b. USE CASE
% ------------------------------------------------------------------
\section{Descrizione degli Use Case e Realizzazione}
In questa sezione viene descritto come gli oggetti collaborano per realizzare le funzionalità principali.

\subsection{UC1: Creazione di una Voce di Tinteggiatura}
\textbf{Descrizione:} L'utente seleziona un ciclo di tinteggiatura e inserisce i mq;
\begin{itemize}
\item\textbf{Specifica:} Nel progetto, per “tinteggiatura” si intendono i cicli associati alle categorie  \textit{Interno} ed \textit{Esterno}.
    \item \textbf{Interazione Oggetti:}
    \begin{enumerate}
        \item \texttt{GestioneInputUI} acquisisce l'input utente (categoria, eventuale sottocategoria, ciclo selezionato e mq).
        \item \texttt{CalcolatorePreventivo} viene configurato con la strategia \texttt{RegolaTinteggiatura}.
        \item Il metodo \texttt{aggiungiLavoro()} invoca \texttt{RegolaTinteggiatura::creaVoce()}.
        \item Viene istanziato un oggetto \texttt{VoceTinteggiatura} che interroga \texttt{ListinoPrezzi} per ottenere il costo unitario.
        \item L'oggetto creato viene spostato (\textit{move}) nel vettore di \texttt{Preventivo}.
    \end{enumerate}
\end{itemize}

\subsection{UC2: Creazione di una Voce Cartongesso (Builder)}
\textbf{Descrizione:} L'utente inserisce una lavorazione complessa in cartongesso.
\begin{itemize}
    \item \textbf{Interazione Oggetti:}
    \begin{enumerate}
        \item \texttt{CalcolatorePreventivo} usa la strategia \texttt{RegolaCartongesso}.
        \item La regola istanzia un \texttt{VoceCartongessoBuilder}.
        \item Il Builder viene configurato passo-passo (\texttt{setMq}, \texttt{setNomeCiclo}, \texttt{setListino}, \texttt{setGrado}).
        \item Il metodo \texttt{build()} finalizza l'oggetto e lo restituisce al \texttt{Preventivo}.
    \end{enumerate}
\end{itemize}

\subsection{UC3: Esportazione Preventivo}
\textbf{Descrizione:} L'utente decide di salvare il preventivo su file (TXT e/o CSV).
\begin{itemize}
    \item \textbf{Interazione Oggetti:}
    \begin{enumerate}
        \item Il \texttt{main} invoca la classe statica \texttt{SalvataggioPreventivo}.
        \item In base alla scelta, viene chiamato \texttt{salvaPreventivoSuTxt()} e/o \texttt{salvaPreventivoSuCsv()} (oppure \texttt{salvaPreventivoConcorrente()} per eseguire i due salvataggi in parallelo).
        \item I metodi richiedono al \texttt{Preventivo} i dati tramite getter e iterazione polimorfica sulle \texttt{VoceCosto}.
        \item Vengono aperti gli stream \texttt{std::ofstream} e scritti i dati su disco; eventuali errori di I/O vengono gestiti tramite eccezioni.
    \end{enumerate}
\end{itemize}


% ------------------------------------------------------------------
% 8c. BASE DI DATI
% ------------------------------------------------------------------
\section{Gestione Dati e Persistenza}
L'applicazione non utilizza un DBMS relazionale, ma si appoggia al file system per la persistenza dei dati tramite file di testo strutturati.

\subsection{Struttura dei File}
La classe \texttt{SalvataggioPreventivo} gestisce due formati di output:

\begin{description}
    \item[Formato TXT (Report Leggibile)] \hfill \\
    Pensato per la lettura umana. Struttura:
    \begin{verbatim}
    PREVENTIVO: [ID_Preventivo]
    CLIENTE: [Nome_Cliente]
    STATO IMMOBILE: [Nuovo/Abitato/...]
    ----------------------------------------
    [Nome Voce] - [Mq] mq - [Prezzo] EUR
    ...
    ----------------------------------------
    TOTALE: [Importo] EUR
    \end{verbatim}

    \item[Formato CSV (Interscambio Dati)] \hfill \\
    Pensato per l'importazione in fogli di calcolo (Excel). I campi sono separati da punto e virgola (;).
    Il file contiene una riga di intestazione, una riga per ogni voce e tre righe finali di riepilogo (imponibile, IVA, totale).
    \begin{verbatim}
    TipoVoce;Nome;Unita;Quantita;PrezzoUnitario;Coefficiente;Subtotale
    Tinteggiatura;Lavabile Interna;mq;50;6.50;1.00;325.00
    Cartongesso;Controsoffitto;mq;20;12.00;1.20;288.00
    TotaleImponibile;;;;;;613.00
    IVA(22%);;;;;;134.86
    TotaleComplessivo;;;;;;747.86
    \end{verbatim}
\end{description}

Il \textbf{Listino Prezzi} è inizializzato all'avvio tramite il modulo \texttt{ListinoDefault}, che popola le mappe della classe \texttt{ListinoPrezzi} con valori predefiniti definiti nel codice sorgente.


% ------------------------------------------------------------------
% 8d. INTERAZIONE
% ------------------------------------------------------------------
\section{Modalità di Interazione (I/O)}
L'interazione con l'utente è di tipo testuale (CLI - Command Line Interface) ed è gestita dalla classe \texttt{GestioneInputUI}.
\subsection{Flusso di Interazione}
Il flusso è guidato da prompt testuali (CLI) e si articola in:

\begin{enumerate}
    \item \textbf{Inizializzazione:} generazione ID preventivo, inserimento nome cliente e selezione stato immobile (Nuovo / Disabitato / Abitato).
    \item \textbf{Loop inserimento voci:}
       \begin{verbatim}
       - Seleziona categoria (Interno / Esterno / Cartongesso)
       - Seleziona sottocategoria (in base alla categoria)
       - Seleziona ciclo di lavorazione dal CatalogoCicli (0 = Torna indietro)
       - Inserisci mq (validazione: > 0 e <= 1.000.000)
       - Conferma: "Aggiungere altra voce? (S/N)"
       \end{verbatim}
    \item \textbf{Chiusura:} ordinamento delle voci, stampa riepilogo e salvataggio su file TXT e CSV (in parallelo).
\end{enumerate}

\subsection{Flusso di Interazione}
Il sistema presenta un menu interattivo ciclico:
\begin{enumerate}
    \item \textbf{Input Iniziale:} Richiesta nome cliente e stato immobile (selezione numerica 1-3).
    \item \textbf{Menu Principale (Loop):}
       \begin{verbatim}
       1) Seleziona tipologia cantiere (Nuovo / Disabitato / Abitato)
       2) Seleziona categoria (Interno / Esterno / Cartongesso)
       3) Seleziona sottocategoria (es. Interno civile / Cartongesso controsoffitti / ...)
       4) Seleziona ciclo di lavorazione (da CatalogoCicli)
       5) Inserisci mq
       6) Conferma inserimento o seleziona S per aggiungere altre voci
       7) Stampa riepilogo finale e salvataggio TXT/CSV
       \end{verbatim}
    \item \textbf{Sottomenu Categorie:} In base alla categoria scelta (Interno/Esterno/Cartongesso) e alla sottocategoria, viene mostrato l'elenco dei cicli disponibili prelevati da \texttt{CatalogoCicli} (es. "1. Traspirante", "2. Lavabile").
    \item \textbf{Input Quantitativo:} Richiesta della superficie in mq (con validazione per impedire valori negativi).
    \item \textbf{Output Finale:} Messaggio di conferma salvataggio e chiusura.
\end{enumerate}

La classe \texttt{Utils} fornisce funzioni di supporto per la gestione e validazione dell'input
(\texttt{trim}, \texttt{leggiIntero}, \texttt{leggiDouble}, \texttt{chiediConferma}, \texttt{nomeClienteValido})
e una funzione per ottenere il tempo locale in modo thread-safe (\texttt{getLocalTimeSafe}).

% ------------------------------------------------------------------
% 9. ALTRE INDICAZIONI UTILI
% ------------------------------------------------------------------
\chapter{Dettagli Tecnici Aggiuntivi}

\section{Librerie Integrate}
Per garantire la massima portabilità e ridurre le dipendenze esterne, il progetto è stato sviluppato utilizzando esclusivamente la \textbf{Libreria Standard C++ (STL)}. Non sono state integrate librerie di terze parti (come Boost o Qt).

Di seguito il dettaglio delle librerie standard utilizzate e del loro scopo nel progetto:

\begin{description}
    \item[\texttt{<thread>}, \texttt{<mutex>}, \texttt{<atomic>}, \texttt{<chrono>}] \hfill \\
    Usate nel modulo \texttt{SalvataggioPreventivo} per eseguire il salvataggio TXT e CSV in parallelo (thread),
    sincronizzare l'output su console (mutex) e gestire lo stato di avanzamento/completamento (atomic) con attese temporizzate (chrono).

    \item[\texttt{<numeric>}] \hfill \\
    Usata in \texttt{Preventivo::totale()} tramite \texttt{std::accumulate} per sommare i subtotali delle voci con una lambda.

    \item[\texttt{<set>}] \hfill \\
    Usata in \texttt{Preventivo} per mantenere un set di chiavi logiche ed evitare duplicati di lavorazioni (unendo le quantità se la voce è già presente).

    \item[\texttt{<sstream>} e \texttt{<ctime>}] \hfill \\
    Usate per costruire il riepilogo (\texttt{std::ostringstream}) e formattare la data (\texttt{std::tm}, \texttt{std::strftime}).

    \item[\texttt{<stdexcept>}] \hfill \\
    Usata per la gestione degli errori tramite eccezioni (es. file non apribili, listino non valido).

    \item[\texttt{<iostream>} e \texttt{<iomanip>}] \hfill \\
    Utilizzate per la gestione dell'Input/Output su console. In particolare, \texttt{<iomanip>} è fondamentale per la formattazione monetaria (es. \texttt{std::fixed}, \texttt{std::setprecision(2)}) per mostrare i prezzi con due cifre decimali.

    \item[\texttt{<fstream>}] \hfill \\
    Utilizzata dalla classe \texttt{SalvataggioPreventivo} per le operazioni di I/O su file (scrittura dei report TXT e CSV).

    \item[\texttt{<memory>}] \hfill \\
    Cruciale per la gestione moderna della memoria. Fornisce i template per gli smart pointers:
    \begin{itemize}
        \item \texttt{std::unique\_ptr}: Usato nel vettore di \texttt{Preventivo} per il possesso esclusivo delle voci.
        \item \texttt{std::shared\_ptr}: Usato per condividere l'istanza del \texttt{ListinoPrezzi} tra le varie componenti (Builder, Regole) senza duplicarla.
    \end{itemize}

    \item[\texttt{<vector>} e \texttt{<map>}] \hfill \\
    Implementano i container dati dinamici.
    \begin{itemize}
        \item \texttt{std::map}: Scelta algoritmica precisa per il \texttt{ListinoPrezzi}. Garantisce una ricerca dei prezzi con complessità logaritmica $O(\log n)$ basata su chiavi stringa, molto più efficiente di una scansione lineare su array.
    \end{itemize}

    \item[\texttt{<algorithm>}] \hfill \\
    Inclusa per l'utilizzo di algoritmi generici, in particolare \texttt{std::sort}, utilizzato per ordinare le voci del preventivo.

    \item[\texttt{<limits>}] \hfill \\
    Utilizzata nella classe \texttt{Utils} per pulire il buffer di input (\texttt{std::numeric\_limits}) e rendere robusta l'interfaccia contro inserimenti errati dell'utente.
\end{description}

\section{Algoritmi Utilizzati}
Sebbene il software non implementi algoritmi di calcolo scientifico complessi, fa uso di pattern algoritmici strutturali e di manipolazione dati:

\begin{enumerate}
    \item \textbf{Ordinamento (Sorting Customizzato):}
    Nel metodo \texttt{Preventivo::ordinaPerNome()}, viene utilizzato l'algoritmo \texttt{std::sort}. È stata implementata una \textit{Lambda Function} come comparatore personalizzato per ordinare i puntatori \texttt{unique\_ptr<VoceCosto>} in base al nome della voce puntata (dereferenziazione e confronto di stringhe).
    \\ \textit{Complessità media:} $O(n \log n)$.

    \item \textbf{Iterazione Polimorfica:}
    L'algoritmo di calcolo del totale (\texttt{Preventivo::totale()}) si basa sull'iterazione lineare su un container eterogeneo. Il sistema sfrutta il \textit{Dynamic Dispatch} (binding dinamico) per invocare la versione corretta del metodo \texttt{subtotale()} a runtime, a seconda che l'oggetto sia una Tinteggiatura o un Cartongesso.
    Nell'implementazione, la somma viene realizzata tramite \texttt{std::accumulate} con una lambda che invoca \texttt{subtotale()} su ciascuna voce.
    \\ \textit{Complessità:} $O(n)$.

    \item \textbf{Ricerca Associativa:}
    Per il recupero dei prezzi dal listino, non viene usata una ricerca sequenziale, ma una ricerca associativa su albero bilanciato (struttura interna di \texttt{std::map}). Questo permette di mantenere alte prestazioni anche qualora il listino dovesse contenere migliaia di voci.
    \\ \textit{Complessità:} $O(\log n)$.

    \item \textbf{Validazione Input (Robustezza):}
    È stata implementata una validazione robusta dell'input basata su \texttt{std::getline}:
    le funzioni \texttt{leggiIntero} e \texttt{leggiDouble} leggono l'intera riga, applicano \texttt{trim} e convertono
    tramite \texttt{std::stoi}/\texttt{std::stod}. Viene inoltre controllato che non restino caratteri extra
    (es. input del tipo \texttt{12abc}), e in caso di errore l'inserimento viene richiesto nuovamente.
    La classe \texttt{GestioneInputUI} utilizza queste funzioni per minimizzare gli errori dell'utente.
\end{enumerate}
% ------------------------------------------------------------------
% 10. BIBLIOGRAFIA
% ------------------------------------------------------------------
\begin{thebibliography}{99}

    % 1. Materiale del Corso
    \bibitem{materiale_corso}
    Prof. E. Blanzieri, Prof. P. Roberti.
    \textit{Materiale didattico del corso di Programmazione Avanzata}.
    Università di Trento, Anno Accademico 2025/2026.

    % 2. Documentazione Tecnica C++ (Fondamentale per la STL)
    \bibitem{cppreference}
    CppReference.
    \textit{C++ Standard Library documentation (std::unique\_ptr, std::map)}.
    Disponibile su: \url{https://en.cppreference.com/}
    (Consultato per la gestione della memoria e dei container STL).

    % 3. Design Patterns (Per giustificare Builder e Strategy)
    \bibitem{refactoring_guru}
    Refactoring.Guru.
    \textit{Design Patterns: Builder, Strategy and Factory Method}.
    Disponibile su: \url{https://refactoring.guru/design-patterns/cpp}
    (Riferimento per l'implementazione architetturale degli oggetti).

    % 4. AI
    \bibitem{chatgpt}
    OpenAI.
    \textit{ChatGPT }.
    Utilizzato come supporto per la revisione del codice. 2025.


\end{thebibliography}
\end{document}
