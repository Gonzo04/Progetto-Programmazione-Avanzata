\documentclass[12pt, a4paper]{report}

% --- PACCHETTI FONDAMENTALI ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\usepackage{graphicx}       % Per le immagini (UML)
\usepackage{geometry}       % Per i margini
\usepackage{hyperref}       % Per l'indice cliccabile
\usepackage{listings}       % Per il codice C++
\usepackage{xcolor}         % Per i colori del codice
\usepackage{float}          % Per posizionare le immagini esattamente dove vuoi

% --- CONFIGURAZIONE MARGINI ---
\geometry{
    a4paper,
    top=2.5cm,
    bottom=2.5cm,
    left=3cm,
    right=3cm
}

% --- CONFIGURAZIONE CODICE C++ ---
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    language=C++,
    frame=single,
    columns=fullflexible,
    xleftmargin=1.5em

}
\lstset{style=mystyle}

% --- INFORMAZIONI DOCUMENTO ---
\newcommand{\titoloProgetto}{Gestione Preventivi EdilColor - Stima costi tinteggiatura, decorativi e cartongesso}
\newcommand{\nomeGruppo}{Gruppo EdilColor Team}
\newcommand{\versioneDoc}{1.0}
\newcommand{\dataDoc}{\today}

\begin{document}

% ------------------------------------------------------------------
% 1. FRONTESPIZIO (Titolo, Gruppo, Data, Componenti)
% ------------------------------------------------------------------
\begin{titlepage}
    \centering
    \vspace*{1cm}

    \Huge
    \textbf{\titoloProgetto}

    \vspace{0.5cm}
    \LARGE
    \nomeGruppo

    \vspace{1.5cm}

    \textbf{Documentazione di Progetto}

    \vspace{0.5cm}
    \large
    Versione \versioneDoc

    \vfill

    \textbf{Componenti del Gruppo:}
    \begin{itemize}
        \centering
        \item Nicola Avellino (243294)
        \item Riccardo Gonzato (246476)
    \end{itemize}

    \vfill

    \large
    \dataDoc

\end{titlepage}

% ------------------------------------------------------------------
% 4. INDICE
% ------------------------------------------------------------------
\tableofcontents
\newpage

% ------------------------------------------------------------------
% ------------------------------------------------------------------
% 5. DESCRIZIONE DEL PROGETTO
% ------------------------------------------------------------------
\chapter{Descrizione del Progetto}

L'applicativo realizzato nasce per rispondere a una specifica esigenza operativa nel rapporto tra \textbf{committente} (cliente) e \textbf{professionista} (impresa).

Spesso, infatti, il cliente necessita unicamente di un ordine di grandezza immediato dei costi per valutare la fattibilità di un lavoro, mentre il professionista si trova a investire tempo prezioso in sopralluoghi e calcoli analitici anche per richieste che, frequentemente, non si traducono in commesse reali.

Il software risolve questa inefficienza strutturale offrendo un vantaggio reciproco immediato:

\begin{itemize}
    \item \textbf{Per il Cliente:} Fornisce istantaneamente un'idea verosimile di spesa (\textit{"stima preliminare"}), senza attese e senza l'impegno psicologico di richiedere un preventivo formale.

    \item \textbf{Per il Professionista:} Funge da \textit{filtro preliminare}, automatizzando la fase di primo contatto. Questo permette all'impresa di dedicare le risorse umane e il tempo tecnico esclusivamente alle fasi esecutive o alle trattative già confermate.
\end{itemize}

\section{Obiettivi del Progetto}
Oltre alla risoluzione della problematica operativa, il progetto si pone precisi obiettivi tecnici e funzionali:

\begin{enumerate}
    \item \textbf{Rapidità di Utilizzo:} Minimizzare il numero di input richiesti all'utente (mq,grado difficoltà e tipologia), delegando al sistema la complessità del calcolo dei materiali e della manodopera.

    \item \textbf{Coerenza dei Prezzi:} Standardizzare le quotazioni applicando listini predefiniti e coefficienti di difficoltà (es. \textit{locale abitato} vs \textit{nuovo}) in modo automatico, eliminando la soggettività e l'errore umano tipico delle stime "a braccio".

    \item \textbf{Architettura Estendibile (OOD):} Realizzare un sistema software basato su una solida progettazione a oggetti. L'uso di \textit{Design Pattern} (come Builder e Strategy) garantisce che l'aggiunta futura di nuove categorie di lavori (es. pavimentazioni) non richieda la riscrittura del codice esistente, ma solo l'estensione delle classi base.
\end{enumerate}

% ------------------------------------------------------------------
% 6. REQUISITI
% ------------------------------------------------------------------
\chapter{Requisiti del Sistema}
In questo capitolo vengono dettagliati i requisiti funzionali (RF) e non funzionali (RNF) che hanno guidato lo sviluppo dell'applicazione.

\section{Requisiti Funzionali}
I requisiti funzionali descrivono i comportamenti specifici e le funzioni che il sistema mette a disposizione dell'utente.

\begin{itemize}
    \item \textbf{RF1 - Gestione del Contesto Operativo (Difficoltà):}
    Il sistema deve permettere all'utente di definire lo stato dell'immobile (es. \textit{Nuovo, Abitato, Disabitato}). Sulla base di questa scelta, l'applicazione deve applicare automaticamente dei \textbf{coefficienti correttivi} al listino base per adeguare il prezzo alla complessità logistica.

    \item \textbf{RF2 - Gestione Listini Centralizzata:}
    Il sistema utilizza un catalogo dei cicli (interno/esterno/cartongesso) per presentare le lavorazioni disponibili e un listino prezzi per gestire coefficienti di difficoltà e prezzi al mq delle lavorazioni. I coefficienti correttivi vengono applicati automaticamente in base allo stato dell'immobile.

    \item \textbf{RF3 - Creazione e Composizione Preventivi:}
    L'utente deve poter creare un nuovo preventivo (associato a un ID univoco e a un cliente) e popolarlo aggiungendo diverse tipologie di voci di costo. Il sistema deve supportare l'inserimento di:
    \begin{itemize}
        \item \textit{Voci Semplici:} (es. Tinteggiature) che richiedono solo la superficie.
        \item \textit{Voci Complesse:} (es. Cartongesso) create tramite Builder in ottica estendibile; nella versione attuale la configurazione è semplificata.
    \end{itemize}

    \item \textbf{RF4 - Calcolo Automatico dei Totali:}
    Il sistema calcola il costo di ogni voce (mq $\times$ prezzo unitario $\times$ coefficiente) tramite il metodo \texttt{subtotale()} delle singole lavorazioni. Il totale complessivo viene calcolato quando richiesto (riepilogo e/o salvataggio) iterando polimorficamente sulle voci del preventivo.

    \item \textbf{RF5 - Persistenza e Esportazione Dati:}
    Il preventivo viene esportato su file in formato TXT e CSV tramite funzioni dedicate del modulo di salvataggio.
    Il salvataggio dei due formati viene eseguito in \textbf{concorrenza} (due task paralleli) con sincronizzazione dell'output su console.
    Nel CSV è presente un'intestazione e una riga per ogni voce; seguono righe di riepilogo (imponibile, IVA, totale).

   \item \textbf{RF6 - Interfaccia Utente (CLI):}
    L'interazione avviene tramite console, guidando l'utente con prompt e selezioni numeriche contestuali (categorie/sottocategorie/cicli) e validazione robusta dell'input per minimizzare gli errori.
\end{itemize}

\section{Requisiti Non Funzionali}
I requisiti non funzionali definiscono gli attributi di qualità del sistema e i vincoli progettuali.

\begin{itemize}
    \item \textbf{RNF1 - Architettura Object-Oriented (OOD):}
    Il sistema deve essere progettato seguendo rigorosamente il paradigma a oggetti. Deve utilizzare il \textbf{Polimorfismo} per trattare in modo uniforme lavorazioni diverse (tramite classe astratta \texttt{VoceCosto}) e garantire l'incapsulamento dei dati.

    \item \textbf{RNF2 - Estendibilità (Open/Closed Principle):}
    L'architettura deve permettere l'aggiunta di nuove categorie di lavorazioni (es. Pavimentazioni) o nuove regole di calcolo senza dover modificare la logica del gestore dei preventivi, ma estendendo le classi esistenti.

    \item \textbf{RNF3 - Integrità dei Dati:}
    L'uso di puntatori intelligenti (\texttt{std::unique\_ptr}, \texttt{std::shared\_ptr}) è richiesto per garantire una corretta gestione della memoria (RAII), prevenendo memory leak durante la creazione e distruzione dei preventivi.

    \item \textbf{RNF4 - Performance:}
    Il calcolo del preventivo deve essere istantaneo al momento dell'inserimento dei dati, senza latenze percepibili dall'utente, se non quelle inserite volutamente per scopo didattico.

    \item \textbf{RNF5 - Affidabilità e Concorrenza Controllata:}
    Le operazioni di I/O (salvataggio TXT/CSV) possono essere eseguite in modo concorrente,
    con sincronizzazione dell'output su console e gestione robusta degli errori tramite eccezioni.
    Gli errori di configurazione (es. chiavi mancanti nel listino) e di I/O (file non apribili) vengono gestiti tramite \textbf{eccezioni}.
\end{itemize}

% ------------------------------------------------------------------
% 7. ATTIVITÀ SVOLTE
% ------------------------------------------------------------------
\chapter{Attività Svolte}
Lo sviluppo del progetto si è articolato in cinque fasi principali:

\begin{enumerate}
    \item \textbf{Analisi del Dominio e dei Requisiti}
    \begin{itemize}
        \item Studio delle dinamiche reali di preventivazione edile per individuare le entità fondamentali (Cliente, Preventivo, Voce di Costo, Listino).
        \item Identificazione delle variabili critiche per il calcolo dei prezzi (superfici, coefficienti di difficoltà ambientale).
        \item Formalizzazione dei requisiti funzionali (es. necessità di salvare su file) e non funzionali (es. estendibilità del codice).
    \end{itemize}

    \item \textbf{Progettazione Architetturale (OOD)}
    \begin{itemize}
        \item Definizione della gerarchia delle classi tramite diagrammi UML.
        \item Scelta delle strutture dati più idonee: utilizzo di \texttt{std::vector} per la gestione dinamica delle voci e \texttt{std::map} per l'accesso rapido ai listini prezzi.
        \item Progettazione della gestione della memoria: decisione di utilizzare \textbf{Smart Pointers} (\texttt{std::unique\_ptr}) per garantire la proprietà esclusiva delle voci all'interno del preventivo e prevenire memory leak.
    \end{itemize}

    \item \textbf{Sviluppo delle Classi Core}
    \begin{itemize}
        \item Implementazione della classe astratta \texttt{VoceCosto} per definire l'interfaccia comune (metodo \texttt{subtotale()} virtuale puro).
        \item Implementazione della classe container \texttt{Preventivo}, capace di gestire polimorficamente collezioni eterogenee di lavori.
        \item Creazione della classe \texttt{ListinoPrezzi} per centralizzare la gestione delle tariffe e dei coefficienti di maggiorazione.
    \end{itemize}

    \item \textbf{Implementazione dei Design Pattern}
    \begin{itemize}
        \item \textbf{Pattern Builder (Predisposizione Architetturale):} Adozione di \texttt{VoceCartongessoBuilder} per la creazione della classe \texttt{VoceCartongesso}. Sebbene nell'attuale versione del software la voce non presenti una struttura interna complessa, il Builder è stato implementato in ottica di \textbf{estendibilità futura}. L'obiettivo è predisporre il sistema ad accogliere configurazioni articolate (es. aggiunta di lastre ignifughe, isolanti acustici o orditure doppie) senza dover ristrutturare l'intero codice.
        \item \textbf{Pattern Strategy:} Implementazione delle classi \texttt{RegolaCosto} per disaccoppiare l'algoritmo di creazione e calcolo dal client, permettendo di selezionare la strategia corretta a runtime in base alla scelta dell'utente.
    \end{itemize}

    \item \textbf{Testing, Debugging e Refactoring}
    \begin{itemize}
        \item Verifica del corretto funzionamento tramite casi d'uso reali (es. creazione di preventivi misti Cartongesso/Tinteggiatura).
        \item Debugging della gestione dell'input utente (classe \texttt{GestioneInputUI}) per evitare crash su inserimenti non validi.
        \item Test di persistenza: verifica della correttezza dei file CSV generati e della loro leggibilità.
    \end{itemize}
    
    \item \textbf{Integrazione funzionalità di C++ moderno (C++11)}
    \begin{itemize}
    \item Implementazione di \textbf{Copy/Move semantics} e overload di operatori (es. \texttt{operator=} e \texttt{operator+=}) per la classe \texttt{Preventivo}.
    \item Uso di \textbf{STL algorithms} (\texttt{std::accumulate}, \texttt{std::sort}) e \textbf{lambda} per calcoli e ordinamenti.
    \item Introduzione di una funzione \textbf{template} di aggregazione per calcoli riutilizzabili.
    \item Salvataggio concorrente (TXT/CSV) con sincronizzazione e gestione robusta degli errori.
    \end{itemize}
    
\end{enumerate}
% ------------------------------------------------------------------
% 8. ATTIVITÀ DI IMPLEMENTAZIONE
% ------------------------------------------------------------------
\chapter{Attività di Implementazione}

In questo capitolo viene descritta l'architettura tecnica della soluzione, dettagliando le scelte di Object-Oriented Design (OOD), la mappatura tra casi d'uso e oggetti software, e le modalità di persistenza dei dati.

% ------------------------------------------------------------------
% 8a. OOD
% ------------------------------------------------------------------
\section{Object-Oriented Design (OOD)}
L'architettura del software si basa su una rigorosa applicazione dei principi della programmazione a oggetti, sfruttando polimorfismo, incapsulamento e smart pointers per la gestione delle risorse.

Di seguito vengono descritte le classi principali, le loro responsabilità e le relazioni cardinali.

\paragraph{Nota di modellazione.}
Alcune componenti di supporto (es. \texttt{Utils}, \texttt{CatalogoCicli}, \texttt{ListinoDefault},
\texttt{IdPreventivoGenerator}, \texttt{SalvataggioPreventivo}) sono implementate come \textbf{funzioni libere}
raggruppate in header dedicati. Nella documentazione e nell'UML vengono descritte come \textit{moduli/utility}
per evidenziarne il ruolo logico, pur non essendo classi istanziabili.

\subsection{Descrizione delle Classi e delle Relazioni}

\begin{description}

% -------------------------
% CLASSI DI DOMINIO (CORE)
% -------------------------

\item[\textbf{Preventivo (Classe)}] \hfill \\
Classe container principale del sistema: rappresenta un preventivo associato a un cliente.
\begin{itemize}
    \item \textbf{Proprietà:}
    \begin{itemize}
        \item \texttt{id\_ (string)}: identificativo univoco.
        \item \texttt{cliente\_ (string)}: nominativo committente.
        \item \texttt{grado\_ (GradoDifficolta)}: stato immobile.
        \item \texttt{voci\_ (vector<unique\_ptr<VoceCosto>>)}: collezione polimorfica di lavorazioni.
        \item \texttt{chiaviVoci\_ (set<string>)}: chiavi logiche (\textit{tipo|nome}) per evitare duplicati/unire quantità.
    \end{itemize}

    \item \textbf{Metodi principali:}
    \begin{itemize}
        \item \texttt{aggiungiVoce(unique\_ptr<VoceCosto>)}: inserisce una voce (move); se già presente unisce la quantità.
        \item \texttt{totale()}: somma i \texttt{subtotale()} delle voci (es. \texttt{std::accumulate}).
        \item \texttt{riepilogo()}: genera una stringa formattata con dettaglio voci e totale.
    \end{itemize}

    \item \textbf{Relazioni:}
    \begin{itemize}
        \item \textbf{Composizione (1 a 0..*):} possiede le \texttt{VoceCosto} tramite \texttt{unique\_ptr}.
    \end{itemize}
\end{itemize}

\item[\textbf{VoceCosto (Classe Astratta)}] \hfill \\
Interfaccia comune per una lavorazione (base astratta).
\begin{itemize}
    \item \textbf{Proprietà (protected):} \texttt{nome\_}, \texttt{unitaMisura\_}, \texttt{quantita\_}, \texttt{prezzoUnitario\_}, \texttt{coefficiente\_}.
    \item \textbf{Metodi:}
    \begin{itemize}
        \item \texttt{tipoVoce() (virtual pure)}: etichetta logica (stampe/CSV).
        \item \texttt{subtotale() (virtual pure)}: calcolo costo voce.
        \item \texttt{clone()}: supporto alla copia profonda (usato da copy semantics/Prototype se implementato).
    \end{itemize}
    \item \textbf{Relazioni:} generalizzazione verso \texttt{VoceTinteggiatura} e \texttt{VoceCartongesso}.
\end{itemize}

\item[\textbf{VoceTinteggiatura (Classe Concreta)}] \hfill \\
Implementa una lavorazione di tinteggiatura/ciclo interno-esterno.
\begin{itemize}
    \item \textbf{Costruzione:} recupera prezzo da \texttt{ListinoPrezzi} e applica coefficiente in base a \texttt{GradoDifficolta}.
    \item \textbf{Relazioni:} dipende da \texttt{ListinoPrezzi} e \texttt{GradoDifficolta}.
\end{itemize}

\item[\textbf{VoceCartongesso (Classe Concreta)}] \hfill \\
Implementa una lavorazione in cartongesso.
\begin{itemize}
    \item \textbf{Costruzione:} recupera prezzo da \texttt{ListinoPrezzi} e applica coefficiente in base a \texttt{GradoDifficolta}.
    \item \textbf{Relazioni:} dipende da \texttt{ListinoPrezzi} e \texttt{GradoDifficolta}.
\end{itemize}

\item[\textbf{ListinoPrezzi (Classe)}] \hfill \\
Database in-memory di prezzi e coefficienti.
\begin{itemize}
    \item \textbf{Struttura dati:} mappe associative (es. \texttt{std::map<string,double>} per prezzi e \texttt{std::map<GradoDifficolta,double>} per coefficienti).
\end{itemize}

% -------------------------
% STRATEGY + BUILDER
% -------------------------

\item[\textbf{VoceCartongessoBuilder (Classe)}] \hfill \\
Builder per creare in modo controllato una \texttt{VoceCartongesso} (predisposizione a voci più complesse).
\begin{itemize}
    \item \textbf{Metodi tipici:} \texttt{setNomeCiclo()}, \texttt{setMq()}, \texttt{setListino()}, \texttt{setGrado()}, \texttt{build()}.
    \item \textbf{Relazioni:} usa \texttt{ListinoPrezzi} (spesso via \texttt{shared\_ptr}) e istanzia \texttt{VoceCartongesso}.
\end{itemize}

\item[\textbf{CalcolatorePreventivo (Classe)}] \hfill \\
Orchestratore che seleziona a runtime la strategia corretta (Strategy) e aggiunge la voce al \texttt{Preventivo}.
\begin{itemize}
    \item \textbf{Proprietà:} \texttt{regola\_ (const RegolaCosto*)} (non owning).
    \item \textbf{Metodi:} \texttt{setRegola()}, \texttt{aggiungiLavoro()}.
\end{itemize}

\item[\textbf{RegolaCosto (Classe Astratta - Strategy)}] \hfill \\
Interfaccia della strategia di creazione di una \texttt{VoceCosto}.
\begin{itemize}
    \item \textbf{Metodo chiave:} \texttt{creaVoce(...)} (virtual pure) $\rightarrow$ \texttt{unique\_ptr<VoceCosto>}.
    \item \textbf{Relazioni:} generalizzazione verso \texttt{RegolaTinteggiatura} e \texttt{RegolaCartongesso}.
\end{itemize}

\item[\textbf{RegolaTinteggiatura (Classe Concreta - Strategy)}] \hfill \\
Crea una \texttt{VoceTinteggiatura} quando l’utente seleziona cicli interno/esterno.
\begin{itemize}
    \item \textbf{Dipendenze:} \texttt{ListinoPrezzi}, \texttt{GradoDifficolta}, dati selezionati da UI.
\end{itemize}

\item[\textbf{RegolaCartongesso (Classe Concreta - Strategy)}] \hfill \\
Crea una \texttt{VoceCartongesso} usando il Builder.
\begin{itemize}
    \item \textbf{Dipendenze:} \texttt{ListinoPrezzi}, \texttt{GradoDifficolta}, \texttt{VoceCartongessoBuilder}.
\end{itemize}

% -------------------------
% UI E MODULI (FUNZIONI LIBERE)
% -------------------------

\item[\textbf{GestioneInputUI (Classe stateless)}] \hfill \\
Interfaccia CLI: menu e validazione, implementata come classe senza stato (metodi statici).
\begin{itemize}
    \item \textbf{Metodi:} \texttt{chiediGradoDifficolta()}, \texttt{chiediCategoriaLavoro()}, \texttt{chiediSottoCategoriaLavoro()}, \texttt{menuCicliPerCategoria()}.
    \item \textbf{Relazioni:} usa \texttt{CatalogoCicli}.
\end{itemize}

\item[\textbf{CatalogoCicli (Modulo)}] \hfill \\
Catalogo statico delle lavorazioni disponibili (dati + funzioni di accesso).
\begin{itemize}
    \item \textbf{Entità:} \texttt{CicloInfo} e funzioni tipo \texttt{getNumeroCicli()}, \texttt{getCiclo(index)}, helper per UI.
\end{itemize}

\item[\textbf{ListinoDefault (Modulo)}] \hfill \\
Inizializzazione del listino standard all’avvio.
\begin{itemize}
    \item \textbf{Funzione:} \texttt{caricaListinoDefault(ListinoPrezzi\&)}.
\end{itemize}

\item[\textbf{Utils (Modulo)}] \hfill \\
Funzioni di supporto (I/O robusto, validazioni, utility).
\begin{itemize}
    \item \textbf{Esempi:} \texttt{trim()}, \texttt{leggiIntero()}, \texttt{leggiDouble()}, \texttt{nomeClienteValido()}, \texttt{chiediConferma()}, \texttt{getLocalTimeSafe()}.
\end{itemize}

\item[\textbf{IdPreventivoGenerator (Modulo)}] \hfill \\
Generazione dell’ID in formato \texttt{PYYYYMMDD-XXX}.
\begin{itemize}
    \item \textbf{Funzione:} \texttt{generaIdPreventivo()}.
\end{itemize}

\item[\textbf{SalvataggioPreventivo (Modulo)}] \hfill \\
Persistenza su file (TXT/CSV).
\begin{itemize}
    \item \textbf{Funzioni:} \texttt{salvaPreventivoSuTxt()}, \texttt{salvaPreventivoSuCsv()}, \texttt{salvaPreventivoConcorrente()} (se presente).
\end{itemize}

\end{description}


% ------------------------------------------------------------------
% 8b. USE CASE
% ------------------------------------------------------------------
\section{Descrizione degli Use Case e Realizzazione}
In questa sezione viene descritto come gli oggetti collaborano per realizzare le funzionalità principali.

\subsection{UC1: Creazione di una Voce di Tinteggiatura}
\textbf{Descrizione:} L'utente seleziona un ciclo di tinteggiatura e inserisce i mq;
\begin{itemize}
\item\textbf{Specifica:} Nel progetto, per “tinteggiatura” si intendono i cicli associati alle categorie  \textit{Interno} ed \textit{Esterno}.
    \item \textbf{Interazione Oggetti:}
    \begin{enumerate}
        \item \texttt{GestioneInputUI} acquisisce l'input utente (categoria, eventuale sottocategoria, ciclo selezionato e mq).
        \item \texttt{CalcolatorePreventivo} viene configurato con la strategia \texttt{RegolaTinteggiatura}.
        \item Il metodo \texttt{aggiungiLavoro()} invoca \texttt{RegolaTinteggiatura::creaVoce()}.
        \item Viene istanziato un oggetto \texttt{VoceTinteggiatura} che interroga \texttt{ListinoPrezzi} per ottenere il costo unitario.
        \item L'oggetto creato viene spostato (\textit{move}) nel vettore di \texttt{Preventivo}.
    \end{enumerate}
\end{itemize}

\subsection{UC2: Creazione di una Voce Cartongesso (Builder)}
\textbf{Descrizione:} L'utente inserisce una lavorazione complessa in cartongesso.
\begin{itemize}
    \item \textbf{Interazione Oggetti:}
    \begin{enumerate}
        \item \texttt{CalcolatorePreventivo} usa la strategia \texttt{RegolaCartongesso}.
        \item La regola istanzia un \texttt{VoceCartongessoBuilder}.
        \item Il Builder viene configurato passo-passo (\texttt{setMq}, \texttt{setNomeCiclo}, \texttt{setListino}, \texttt{setGrado}).
        \item Il metodo \texttt{build()} finalizza l'oggetto e lo restituisce al \texttt{Preventivo}.
    \end{enumerate}
\end{itemize}

\subsection{UC3: Esportazione Preventivo}
\textbf{Descrizione:} L'utente decide di salvare il preventivo su file (TXT e/o CSV).
\begin{itemize}
    \item \textbf{Interazione Oggetti:}
    \begin{enumerate}
        \item Il \texttt{main} invoca le funzioni del modulo \texttt{SalvataggioPreventivo}
        per esportare il preventivo in formato TXT e CSV (anche in concorrenza).
        \item I metodi richiedono al \texttt{Preventivo} i dati tramite getter e iterazione polimorfica sulle \texttt{VoceCosto}.
        \item Vengono aperti gli stream \texttt{std::ofstream} e scritti i dati su disco; eventuali errori di I/O vengono gestiti tramite eccezioni.
    \end{enumerate}
\end{itemize}


% ------------------------------------------------------------------
% 8c. BASE DI DATI
% ------------------------------------------------------------------
\section{Gestione Dati e Persistenza}
L'applicazione non utilizza un DBMS relazionale, ma si appoggia al file system per la persistenza dei dati tramite file di testo strutturati.

\subsection{Struttura dei File}
Il modulo \texttt{SalvataggioPreventivo} gestisce due formati di output:

\begin{description}
    \item[Formato TXT (Report Leggibile)] \hfill \\
    Pensato per la lettura umana. Struttura:
    \begin{verbatim}
    PREVENTIVO: [ID_Preventivo]
    CLIENTE: [Nome_Cliente]
    STATO IMMOBILE: [Nuovo/Abitato/...]
    ----------------------------------------
    [Nome Voce] - [Mq] mq - [Prezzo] EUR
    ...
    ----------------------------------------
    TOTALE: [Importo] EUR
    \end{verbatim}

    \item[Formato CSV (Interscambio Dati)] \hfill \\
    Pensato per l'importazione in fogli di calcolo (Excel). I campi sono separati da punto e virgola (;).
    Il file contiene una riga di intestazione, una riga per ogni voce e tre righe finali di riepilogo (imponibile, IVA, totale).
    \begin{verbatim}
    TipoVoce;Nome;Unita;Quantita;PrezzoUnitario;Coefficiente;Subtotale
    Tinteggiatura;Lavabile Interna;mq;50;6.50;1.00;325.00
    Cartongesso;Controsoffitto;mq;20;12.00;1.20;288.00
    TotaleImponibile;;;;;;613.00
    IVA(22%);;;;;;134.86
    TotaleComplessivo;;;;;;747.86
    \end{verbatim}
\end{description}

Il \textbf{Listino Prezzi} è inizializzato all'avvio tramite il modulo \texttt{ListinoDefault}, che popola le mappe della classe \texttt{ListinoPrezzi} con valori predefiniti definiti nel codice sorgente.


% ------------------------------------------------------------------
% 8d. INTERAZIONE
% ------------------------------------------------------------------
\section{Modalità di Interazione (I/O)}

\subsection{Flusso di Interazione}
Il flusso dell'applicazione è guidato da un'interfaccia testuale (CLI) e segue la stessa logica descritta dagli Use Case UC1--UC3:

\begin{enumerate}
    \item \textbf{Inizializzazione (preparazione contesto):}
    \begin{itemize}
        \item generazione automatica dell'ID preventivo;
        \item inserimento del nome cliente (con validazione);
        \item selezione dello stato immobile (\texttt{GradoDifficolta}: Nuovo / Disabitato / Abitato).
    \end{itemize}

    \item \textbf{Loop di inserimento lavorazioni (UC1 e UC2):}
    \begin{itemize}
        \item selezione della categoria (Interno / Esterno / Cartongesso);
        \item eventuale selezione della sottocategoria (se prevista dalla categoria);
        \item selezione del ciclo di lavorazione dal \texttt{CatalogoCicli};
        \item inserimento della quantità in mq (validazione: valore $> 0$ e con limiti massimi);
        \item creazione della voce tramite la strategia corretta:
        \begin{itemize}
            \item \textbf{UC1 (Tinteggiatura):} \texttt{RegolaTinteggiatura} crea una \texttt{VoceTinteggiatura} usando prezzo e coefficienti dal \texttt{ListinoPrezzi}.
            \item \textbf{UC2 (Cartongesso):} \texttt{RegolaCartongesso} crea una \texttt{VoceCartongesso} tramite \texttt{VoceCartongessoBuilder}.
        \end{itemize}
        \item conferma dell'utente per aggiungere un'altra voce oppure terminare.
    \end{itemize}

    \item \textbf{Chiusura e salvataggio (UC3):}
    \begin{itemize}
        \item stampa del riepilogo finale e calcolo del totale tramite iterazione polimorfica sulle \texttt{VoceCosto};
        \item esportazione su file TXT e CSV , gestita da \texttt{SalvataggioPreventivo}.
    \end{itemize}
\end{enumerate}

La classe \texttt{GestioneInputUI} gestisce i menu e la validazione, mentre \texttt{Utils} fornisce funzioni di supporto
(\texttt{trim}, \texttt{leggiIntero}, \texttt{leggiDouble}, \texttt{chiediConferma}, \texttt{nomeClienteValido})
e la funzione thread-safe per la data locale (\texttt{getLocalTimeSafe}).


% ------------------------------------------------------------------
% 9. ALTRE INDICAZIONI UTILI
% ------------------------------------------------------------------
\chapter{Dettagli Tecnici Aggiuntivi}

\section{Librerie Integrate}
Per garantire la massima portabilità e ridurre le dipendenze esterne, il progetto è stato sviluppato utilizzando esclusivamente la \textbf{Libreria Standard C++ (STL)}. Non sono state integrate librerie di terze parti (come Boost o Qt).

Di seguito il dettaglio delle librerie standard utilizzate e del loro scopo nel progetto:

\begin{description}
    \item[\texttt{<thread>}, \texttt{<mutex>}, \texttt{<atomic>}, \texttt{<chrono>}] \hfill \\
    Usate nel modulo \texttt{SalvataggioPreventivo} per eseguire il salvataggio TXT e CSV in parallelo (thread),
    sincronizzare l'output su console (mutex) e gestire lo stato di avanzamento/completamento (atomic) con attese temporizzate (chrono).

    \item[\texttt{<string>}] \hfill \\
    Usata per la gestione delle stringhe (\texttt{id\_}, \texttt{cliente\_}, nomi dei cicli, riepiloghi e CSV).

    \item[\texttt{<utility>}] \hfill \\
    Usata per le move semantics (\texttt{std::move}) nel trasferimento di \texttt{unique\_ptr} e nella gestione efficiente degli oggetti.

    \item[\texttt{<numeric>}] \hfill \\
    Usata in \texttt{Preventivo::totale()} tramite \texttt{std::accumulate} per sommare i subtotali delle voci con una lambda.

    \item[\texttt{<set>}] \hfill \\
    Usata in \texttt{Preventivo} per mantenere un set di chiavi logiche ed evitare duplicati di lavorazioni (unendo le quantità se la voce è già presente).

    \item[\texttt{<sstream>} e \texttt{<ctime>}] \hfill \\
    Usate per costruire il riepilogo (\texttt{std::ostringstream}) e formattare la data (\texttt{std::tm}, \texttt{std::strftime}).

    \item[\texttt{<stdexcept>}] \hfill \\
    Usata per la gestione degli errori tramite eccezioni (es. file non apribili, listino non valido).

    \item[\texttt{<iostream>} e \texttt{<iomanip>}] \hfill \\
    Utilizzate per la gestione dell'Input/Output su console. In particolare, \texttt{<iomanip>} è fondamentale per la formattazione monetaria (es. \texttt{std::fixed}, \texttt{std::setprecision(2)}) per mostrare i prezzi con due cifre decimali.

    \item[\texttt{<fstream>}] \hfill \\
    Utilizzata dal modulo \texttt{SalvataggioPreventivo} per le operazioni di I/O su file (scrittura dei report TXT e CSV).

    \item[\texttt{<memory>}] \hfill \\
    Cruciale per la gestione moderna della memoria. Fornisce i template per gli smart pointers:
    \begin{itemize}
        \item \texttt{std::unique\_ptr}: Usato nel vettore di \texttt{Preventivo} per il possesso esclusivo delle voci.
        \item \texttt{std::shared\_ptr}: Usato per condividere l'istanza del \texttt{ListinoPrezzi} tra le varie componenti (Builder, Regole) senza duplicarla.
    \end{itemize}

    \item[\texttt{<vector>} e \texttt{<map>}] \hfill \\
    Implementano i container dati dinamici.
    \begin{itemize}
        \item \texttt{std::map}: Scelta algoritmica precisa per il \texttt{ListinoPrezzi}. Garantisce una ricerca dei prezzi con complessità logaritmica $O(\log n)$ basata su chiavi stringa, molto più efficiente di una scansione lineare su array.
    \end{itemize}

    \item[\texttt{<algorithm>}] \hfill \\
    Inclusa per l'utilizzo di algoritmi generici, in particolare \texttt{std::sort}, utilizzato per ordinare le voci del preventivo.

    \item[\texttt{<limits>}] \hfill \\
    Utilizzata nella classe \texttt{Utils} per pulire il buffer di input (\texttt{std::numeric\_limits}) e rendere robusta l'interfaccia contro inserimenti errati dell'utente.
\end{description}

\section{Algoritmi Utilizzati}
Sebbene il software non implementi algoritmi di calcolo scientifico complessi, fa uso di pattern algoritmici strutturali e di manipolazione dati:

\begin{enumerate}
    \item \textbf{Ordinamento (Sorting Customizzato):}
    Nel metodo \texttt{Preventivo::ordinaPerNome()}, viene utilizzato l'algoritmo \texttt{std::sort}. È stata implementata una \textit{Lambda Function} come comparatore personalizzato per ordinare i puntatori \texttt{unique\_ptr<VoceCosto>} in base al nome della voce puntata (dereferenziazione e confronto di stringhe).
    \\ \textit{Complessità media:} $O(n \log n)$.

    \item \textbf{Iterazione Polimorfica:}
    L'algoritmo di calcolo del totale (\texttt{Preventivo::totale()}) si basa sull'iterazione lineare su un container eterogeneo. Il sistema sfrutta il \textit{Dynamic Dispatch} (binding dinamico) per invocare la versione corretta del metodo \texttt{subtotale()} a runtime, a seconda che l'oggetto sia una Tinteggiatura o un Cartongesso.
    Nell'implementazione, la somma viene realizzata tramite \texttt{std::accumulate} con una lambda che invoca \texttt{subtotale()} su ciascuna voce.
    \\ \textit{Complessità:} $O(n)$.

    \item \textbf{Ricerca Associativa:}
    Per il recupero dei prezzi dal listino, non viene usata una ricerca sequenziale, ma una ricerca associativa su albero bilanciato (struttura interna di \texttt{std::map}). Questo permette di mantenere alte prestazioni anche qualora il listino dovesse contenere migliaia di voci.
    \\ \textit{Complessità:} $O(\log n)$.

    \item \textbf{Validazione Input (Robustezza):}
    È stata implementata una validazione robusta dell'input basata su \texttt{std::getline}:
    le funzioni \texttt{leggiIntero} e \texttt{leggiDouble} leggono l'intera riga, applicano \texttt{trim} e convertono
    tramite \texttt{std::stoi}/\texttt{std::stod}. Viene inoltre controllato che non restino caratteri extra
    (es. input del tipo \texttt{12abc}), e in caso di errore l'inserimento viene richiesto nuovamente.
    La classe \texttt{GestioneInputUI} utilizza queste funzioni per minimizzare gli errori dell'utente.
\end{enumerate}
% ------------------------------------------------------------------
% 10. BIBLIOGRAFIA
% ------------------------------------------------------------------
\begin{thebibliography}{99}

    % 1. Materiale del Corso
    \bibitem{materiale_corso}
    Prof. E. Blanzieri, Prof. P. Roberti.
    \textit{Materiale didattico del corso di Programmazione Avanzata}.
    Università di Trento, Anno Accademico 2025/2026.

    % 2. Documentazione Tecnica C++ (Fondamentale per la STL)
    \bibitem{cppreference}
    CppReference.
    \textit{C++ Standard Library documentation (std::unique\_ptr, std::map)}.
    Disponibile su: \url{https://en.cppreference.com/}
    (Consultato per la gestione della memoria e dei container STL).

    % 3. Design Patterns (Per giustificare Builder e Strategy)
    \bibitem{refactoring_guru}
    Refactoring.Guru.
    \textit{Design Patterns: Builder, Strategy and Factory Method}.
    Disponibile su: \url{https://refactoring.guru/design-patterns/cpp}
    (Riferimento per l'implementazione architetturale degli oggetti).

    % 4. AI
    \bibitem{chatgpt}
    OpenAI.
    \textit{ChatGPT }.
    Utilizzato come supporto per la revisione del codice. 2025.


\end{thebibliography}
\end{document}
